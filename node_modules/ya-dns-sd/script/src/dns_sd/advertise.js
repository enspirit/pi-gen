"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.advertise = void 0;
const dntShim = __importStar(require("../../_dnt.shims.js"));
const types_js_1 = require("../decode/types.js");
const get_own_address_js_1 = require("../mdns/get_own_address.js");
const responder_js_1 = require("../mdns/responder.js");
/** Advertise a service over multicast DNS.
 *
 * Returns a promise which will reject if fifteen failed attempts to claim a name are made within a ten second interval.
 *
 * If the service has to be renamed due to a conflict, a warning with the new name will be sent to the console.
 */
async function advertise(opts) {
    let attemptsInLastTenSeconds = 0;
    const removalTimers = [];
    const hostToUse = opts.service.host ||
        await (0, get_own_address_js_1.getOwnAddress)(opts.multicastInterface);
    let renameAttempts = 1;
    if (opts.signal) {
        opts.signal.addEventListener("abort", () => {
            attemptsInLastTenSeconds = 16;
            for (const timer of removalTimers) {
                clearTimeout(timer);
            }
        });
    }
    while (attemptsInLastTenSeconds <= 15) {
        const name = renameAttempts > 1
            ? `${opts.service.name} (${renameAttempts})`
            : opts.service.name;
        if (renameAttempts > 1) {
            console.warn(`Renamed to "${name}"`);
        }
        const subtypeLabels = opts.service.subtypes && opts.service.subtypes.length > 0
            ? [...opts.service.subtypes.map((s) => `_${s}`), `_sub`]
            : [];
        const serviceTypeLabels = [
            ...subtypeLabels,
            `_${opts.service.type}`,
            `_${opts.service.protocol}`,
            "local",
        ];
        const fullNameLabels = [name, ...serviceTypeLabels];
        const ptrRecord = {
            NAME: serviceTypeLabels,
            TYPE: types_js_1.ResourceType.PTR,
            CLASS: types_js_1.DnsClass.IN,
            TTL: 120,
            isUnique: false,
            RDATA: fullNameLabels,
            RDLENGTH: 1, // Faking this, it will be encoded properly.
        };
        const srvRecord = {
            NAME: fullNameLabels,
            TYPE: types_js_1.ResourceType.SRV,
            CLASS: types_js_1.DnsClass.IN,
            TTL: 120,
            isUnique: true,
            RDATA: {
                weight: 0,
                priority: 0,
                port: opts.service.port,
                target: fullNameLabels,
            },
            RDLENGTH: 1,
        };
        const txtRecord = {
            NAME: fullNameLabels,
            TYPE: types_js_1.ResourceType.TXT,
            CLASS: types_js_1.DnsClass.IN,
            TTL: 120,
            isUnique: true,
            RDATA: opts.service.txt,
            RDLENGTH: 1,
        };
        const hostNameRecord = {
            NAME: fullNameLabels,
            TYPE: opts.multicastInterface.family === "IPv4"
                ? types_js_1.ResourceType.A
                : types_js_1.ResourceType.AAAA,
            CLASS: types_js_1.DnsClass.IN,
            TTL: 120,
            isUnique: true,
            RDATA: opts.multicastInterface.family === "IPv4"
                ? hostToUse.split(".").map((strNum) => parseInt(strNum))
                : hostToUse,
            RDLENGTH: 1,
        };
        await (0, responder_js_1.respond)({
            proposedRecords: [
                {
                    ...ptrRecord,
                    additional: [
                        srvRecord,
                        txtRecord,
                        hostNameRecord,
                    ],
                },
                {
                    ...srvRecord,
                    additional: [
                        hostNameRecord,
                    ],
                },
                txtRecord,
                hostNameRecord,
            ],
            multicastInterface: opts.multicastInterface,
            signal: opts.signal,
        }).catch(async (failure) => {
            if (failure === "simultaneous_probe") {
                await new Promise((res) => {
                    dntShim.setTimeout(res, 1000);
                });
                return;
            }
            else if (failure === "name_taken") {
                attemptsInLastTenSeconds += 1;
                const removalTimer = dntShim.setTimeout(() => {
                    attemptsInLastTenSeconds -= 1;
                }, 10000);
                removalTimers.push(removalTimer);
                renameAttempts += 1;
            }
            else if (failure === "aborted") {
                return Promise.reject("Advertisement was aborted.");
            }
        });
    }
    for (const timer of removalTimers) {
        clearTimeout(timer);
    }
    return Promise.reject(new Error("Was not able to claim a name after 15 attempts, which indicates shenanigans."));
}
exports.advertise = advertise;
