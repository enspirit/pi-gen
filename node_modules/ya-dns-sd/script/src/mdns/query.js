"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Query = void 0;
const dntShim = __importStar(require("../../_dnt.shims.js"));
const deps_js_1 = require("../../deps.js");
const types_js_1 = require("../decode/types.js");
const fast_fifo_js_1 = require("../fast_fifo.js");
const responder_js_1 = require("./responder.js");
const ONE_SECOND_MS = 1000;
/** The number of milliseconds in an hour. */
const ONE_HOUR_MS = ONE_SECOND_MS * 60 * 60;
/** A continuous multicast DNS query.
 *
 * Reports additions, flushes, and expirations of resource records answering the given query via an asynchronous iterator:
 *
 * ```ts
 * const query = new Query(
 *   [{ name: '_http._tcp.local', recordType: 255 }],
 *   multicastInterface: new MulticastInterface()
 * );
 *
 * for await (const event of query) {
 *   console.log(event)
 * }
 * ```
 */
class Query {
    constructor(questions, multicastInterface) {
        Object.defineProperty(this, "questions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "minterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "recordCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new RecordCache({
                // Teach the cache how to query for expiring records
                onRequery: (record) => {
                    this.sendQuery([{
                            name: record.NAME.join("."),
                            recordType: record.TYPE,
                        }]);
                },
            })
        });
        Object.defineProperty(this, "scheduled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "ended", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "suppressedQuestions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        Object.defineProperty(this, "additionalRecords", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new SimpleRecordStore()
        });
        this.questions = questions;
        this.minterface = multicastInterface;
        // Send the initial query.
        this.scheduleInitialQuery();
        // Long running query for some records.
        (async () => {
            for await (const [message, host] of multicastInterface.messages()) {
                if (this.ended) {
                    break;
                }
                if (multicastInterface.isOwnAddress(host.hostname)) {
                    continue;
                }
                if (message.header.QR === 0) {
                    this.handleQuery(message, host);
                }
                else {
                    this.handleResponse(message);
                }
            }
        })();
    }
    scheduleInitialQuery() {
        // Delay the initial query by random amount between 20 - 120ms.
        const fromNow = Math.random() * (120 - 20) + 20;
        this.scheduleQuery(fromNow, () => {
            this.scheduleFurtherQueries(ONE_SECOND_MS);
        });
    }
    scheduleFurtherQueries(inMs) {
        // Send the query, send again after one second, and then by a factor of two each time. Cap it at 60 mins.
        this.scheduleQuery(inMs, () => {
            this.scheduleFurtherQueries(Math.min(inMs * 2, ONE_HOUR_MS));
        });
    }
    /** Gets all questions given to this Query which we do not already know the answer to, and which we have not recently seen asked by anyone else via multicast. */
    getQuestions() {
        const validQuestions = [];
        for (const question of this.questions) {
            // If it's a suppressed question, don't send it.
            if (this.suppressedQuestions.has(question)) {
                // We only want to suppress it once.
                this.suppressedQuestions.delete(question);
                continue;
            }
            // If it's a question we already know the answer to, don't send it.
            // But ONLY if it's a non-shared record.
            if (question.recordType !== types_js_1.ResourceType.PTR &&
                this.recordCache.knownAnswers([question]).length > 0) {
                continue;
            }
            validQuestions.push(question);
        }
        // Clear the suppressed questions.
        return validQuestions;
    }
    scheduleQuery(inMs, onTimeout) {
        const timer = dntShim.setTimeout(() => {
            this.sendQuery();
            if (onTimeout) {
                onTimeout();
            }
        }, inMs);
        this.scheduled.push(timer);
    }
    handleQuery(query, host) {
        // It's a query.
        // Is this something we sent ourselves?
        if (this.minterface.isOwnAddress(host.hostname)) {
            return;
        }
        // can only suppress if the known answer section is empty
        if (query.answer.length > 0) {
            return;
        }
        // (7.3) If another
        // responder has asked the same question as one this query is about to send,
        // this query can suppress that question since someone already asked for it. So we reschedule the question.
        for (const question of query.question) {
            for (const ourQuestion of this.questions) {
                if (question.QTYPE === ourQuestion.recordType &&
                    question.QNAME.join(".") === ourQuestion.name) {
                    // SUPPRESS THAT CHATTY CATTY RIGHT NOW...
                    this.suppressedQuestions.add(ourQuestion);
                }
            }
        }
    }
    askedQuestionFor(record) {
        for (const question of this.questions) {
            const isRightType = record.TYPE === question.recordType ||
                question.recordType === types_js_1.ResourceType.ANY;
            const isRightName = record.NAME.join(".").toUpperCase() ===
                question.name.toUpperCase();
            if (isRightType && isRightName) {
                return true;
            }
        }
        return false;
    }
    handleResponse(response) {
        // Check if any of the records matches our query...
        let additionalAdded = false;
        for (const record of response.answer) {
            const answersAnyQuestion = this.askedQuestionFor(record);
            if (!answersAnyQuestion) {
                // Not a matching record
                continue;
            }
            else if (additionalAdded === false) {
                // Add all additional records to the cache if there were any answers in this response.
                for (const additionalRecord of response.additional) {
                    this.additionalRecords.addRecord(additionalRecord);
                }
                additionalAdded = true;
            }
            // It IS a matching record, so add it to our cache.
            this.recordCache.addRecord(record);
        }
    }
    /** Sends a DNS query with given questions.
     *
     * If no questions are provided, uses the ones given to the `Query` at construction.
     */
    async sendQuery(questions) {
        const questionsToUse = questions || this.getQuestions();
        if (questionsToUse.length === 0) {
            return;
        }
        // Known answer suppression, RFC 6762 section 7.1.
        // Include answers we already know
        // These should only be shared, non-unique records.
        const knownAnswers = this.recordCache.knownAnswers(questionsToUse);
        const message = {
            header: {
                ID: 0,
                QR: 0,
                OPCODE: 0,
                AA: 0,
                TC: 0,
                RD: 0,
                RA: 0,
                Z: 0,
                AD: 0,
                CD: 0,
                RCODE: 0,
                QDCOUNT: questionsToUse.length,
                ANCOUNT: knownAnswers.length,
                NSCOUNT: 0,
                ARCOUNT: 0,
            },
            question: questionsToUse.map((q) => ({
                QNAME: q.name.split("."),
                QTYPE: q.recordType,
                QCLASS: types_js_1.DnsClass.IN,
            })),
            answer: knownAnswers,
            authority: [],
            additional: [],
        };
        // Send it!
        await this.minterface.send(message);
    }
    /** All answers obtained over the life of this query. */
    answers() {
        return this.recordCache.getRecords();
    }
    /** All additional records obtained from responses which had valid answers in them. */
    additional() {
        return this.additionalRecords.getRecords();
    }
    /** Stop this query from running. */
    end() {
        this.ended = true;
        this.recordCache.close();
        // Clear all the timers.
        for (const timer of this.scheduled) {
            clearTimeout(timer);
        }
    }
    async *[Symbol.asyncIterator]() {
        for await (const event of this.recordCache.events) {
            yield event;
        }
    }
}
exports.Query = Query;
class RecordCache {
    constructor(opts) {
        Object.defineProperty(this, "records", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onRequery", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new fast_fifo_js_1.FastFIFO(16)
        });
        this.onRequery = opts.onRequery;
    }
    close() {
        for (const [record] of this.records) {
            this.removeRecord(record);
        }
        this.events.close();
    }
    getRecords() {
        return Array.from(this.records.keys());
    }
    addRecord(record) {
        const expire = () => {
            this.expireRecord(record);
        };
        const requery = () => {
            this.onRequery(record);
        };
        // Handle goodbye packets with a TTL of 0.
        if (record.TTL === 0) {
            // Set to expire in 1 second (section 10.1 of RFC 6762)
            this.records.set(record, [
                dntShim.setTimeout(() => this.expireRecord(record), 1000),
            ]);
            this.events.push({
                kind: "ADDED",
                record,
            });
            return;
        }
        // If it's unique, flush all records with same name, rrtype, and rrclass.
        if (record.isUnique) {
            for (const [prevRecord] of this.records) {
                if ((0, deps_js_1.shallowEqualArrays)(record.NAME, prevRecord.NAME) &&
                    record.TYPE === prevRecord.TYPE &&
                    record.CLASS === prevRecord.CLASS) {
                    if ((0, responder_js_1.recordSort)(record, prevRecord) === 0) {
                        // RDATA is the same. Don't flush it.
                        return;
                    }
                    this.removeRecord(prevRecord);
                    this.events.push({
                        kind: "FLUSHED",
                        record: prevRecord,
                    });
                }
            }
        }
        // schedule re-query at 80%-82% of record lifetime
        // 85%-87%
        // 90%-92%
        // and 95%-97%
        const timers = [
            dntShim.setTimeout(expire, record.TTL * 1000),
            dntShim.setTimeout(requery, wigglyPercentOf(80, record.TTL * 1000)),
            dntShim.setTimeout(requery, wigglyPercentOf(85, record.TTL * 1000)),
            dntShim.setTimeout(requery, wigglyPercentOf(90, record.TTL * 1000)),
            dntShim.setTimeout(requery, wigglyPercentOf(95, record.TTL * 1000)),
        ];
        this.records.set(record, timers);
        // Emit an addition
        this.events.push({
            kind: "ADDED",
            record,
        });
    }
    expireRecord(record) {
        this.removeRecord(record);
        // Requery for it one last time.
        this.onRequery(record);
        // Emit expiration
        this.events.push({
            kind: "EXPIRED",
            record,
        });
    }
    removeRecord(record) {
        const timers = this.records.get(record);
        if (timers) {
            for (const timer of timers) {
                clearTimeout(timer);
            }
        }
        this.records.delete(record);
    }
    /** Return all records in the cache matching a set of questions. Used for known-answer suppression.*/
    knownAnswers(questions) {
        const knownAnswers = new Set();
        for (const [record] of this.records) {
            let answersAnyQuestion = false;
            for (const question of questions) {
                if (record.TYPE === question.recordType &&
                    record.NAME.join(".").toUpperCase() === question.name.toUpperCase()) {
                    answersAnyQuestion = true;
                }
            }
            if (answersAnyQuestion) {
                knownAnswers.add(record);
            }
        }
        return Array.from(knownAnswers);
    }
}
/** A simple record store which replaces conflicting records. */
class SimpleRecordStore {
    constructor() {
        Object.defineProperty(this, "records", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
    }
    addRecord(record) {
        for (const existingRecord of this.records) {
            if ((0, responder_js_1.isConflicting)(record, existingRecord)) {
                this.records.delete(existingRecord);
            }
        }
        this.records.add(record);
    }
    getRecords() {
        return Array.from(this.records);
    }
}
/** Calculate the given percentage (with +2 wiggle) of a number  */
function wigglyPercentOf(percent, total) {
    const wiggle = Math.random() * (percent + 2 - percent) + percent;
    return (wiggle / 100) * total;
}
