export const END = Symbol("Stream ended.");
export const ERROR = Symbol("Stream errored.");
// Adapted from https://github.com/mafintosh/fast-fifo to turn into AsyncIterable
class FixedFIFO {
    constructor(hwm) {
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "top", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "btm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "next", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {
            throw new Error("Max size for a FixedFIFO should be a power of two");
        }
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
    }
    push(data) {
        if (this.buffer[this.top] !== undefined)
            return false;
        this.buffer[this.top] = data;
        this.top = (this.top + 1) & this.mask;
        return true;
    }
    shift() {
        const last = this.buffer[this.btm];
        if (last === undefined)
            return undefined;
        this.buffer[this.btm] = undefined;
        this.btm = (this.btm + 1) & this.mask;
        return last;
    }
    peek() {
        return this.buffer[this.btm];
    }
    isEmpty() {
        return this.buffer[this.btm] === undefined;
    }
}
export class FastFIFO {
    constructor(hwm) {
        Object.defineProperty(this, "hwm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "head", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
    }
    push(val) {
        if (this.resolve) {
            this.resolve(val);
            this.resolve = null;
            return;
        }
        if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
        }
    }
    shift() {
        const val = this.tail.shift();
        if (val === undefined && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
        }
        return val;
    }
    peek() {
        return this.tail.peek();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    close() {
        this.push(END);
    }
    async *[Symbol.asyncIterator]() {
        while (true) {
            const shifted = this.shift();
            const value = shifted ||
                await new Promise((res) => {
                    this.resolve = res;
                });
            if (value === END || value === ERROR) {
                break;
            }
            yield value;
        }
    }
}
