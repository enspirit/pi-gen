import * as dntShim from "../../_dnt.shims.js";
import { DnsClass, ResourceType, } from "../decode/types.js";
import { getOwnAddress } from "../mdns/get_own_address.js";
import { respond } from "../mdns/responder.js";
/** Advertise a service over multicast DNS.
 *
 * Returns a promise which will reject if fifteen failed attempts to claim a name are made within a ten second interval.
 *
 * If the service has to be renamed due to a conflict, a warning with the new name will be sent to the console.
 */
export async function advertise(opts) {
    let attemptsInLastTenSeconds = 0;
    const removalTimers = [];
    const hostToUse = opts.service.host ||
        await getOwnAddress(opts.multicastInterface);
    let renameAttempts = 1;
    if (opts.signal) {
        opts.signal.addEventListener("abort", () => {
            attemptsInLastTenSeconds = 16;
            for (const timer of removalTimers) {
                clearTimeout(timer);
            }
        });
    }
    while (attemptsInLastTenSeconds <= 15) {
        const name = renameAttempts > 1
            ? `${opts.service.name} (${renameAttempts})`
            : opts.service.name;
        if (renameAttempts > 1) {
            console.warn(`Renamed to "${name}"`);
        }
        const subtypeLabels = opts.service.subtypes && opts.service.subtypes.length > 0
            ? [...opts.service.subtypes.map((s) => `_${s}`), `_sub`]
            : [];
        const serviceTypeLabels = [
            ...subtypeLabels,
            `_${opts.service.type}`,
            `_${opts.service.protocol}`,
            "local",
        ];
        const fullNameLabels = [name, ...serviceTypeLabels];
        const ptrRecord = {
            NAME: serviceTypeLabels,
            TYPE: ResourceType.PTR,
            CLASS: DnsClass.IN,
            TTL: 120,
            isUnique: false,
            RDATA: fullNameLabels,
            RDLENGTH: 1, // Faking this, it will be encoded properly.
        };
        const srvRecord = {
            NAME: fullNameLabels,
            TYPE: ResourceType.SRV,
            CLASS: DnsClass.IN,
            TTL: 120,
            isUnique: true,
            RDATA: {
                weight: 0,
                priority: 0,
                port: opts.service.port,
                target: fullNameLabels,
            },
            RDLENGTH: 1,
        };
        const txtRecord = {
            NAME: fullNameLabels,
            TYPE: ResourceType.TXT,
            CLASS: DnsClass.IN,
            TTL: 120,
            isUnique: true,
            RDATA: opts.service.txt,
            RDLENGTH: 1,
        };
        const hostNameRecord = {
            NAME: fullNameLabels,
            TYPE: opts.multicastInterface.family === "IPv4"
                ? ResourceType.A
                : ResourceType.AAAA,
            CLASS: DnsClass.IN,
            TTL: 120,
            isUnique: true,
            RDATA: opts.multicastInterface.family === "IPv4"
                ? hostToUse.split(".").map((strNum) => parseInt(strNum))
                : hostToUse,
            RDLENGTH: 1,
        };
        await respond({
            proposedRecords: [
                {
                    ...ptrRecord,
                    additional: [
                        srvRecord,
                        txtRecord,
                        hostNameRecord,
                    ],
                },
                {
                    ...srvRecord,
                    additional: [
                        hostNameRecord,
                    ],
                },
                txtRecord,
                hostNameRecord,
            ],
            multicastInterface: opts.multicastInterface,
            signal: opts.signal,
        }).catch(async (failure) => {
            if (failure === "simultaneous_probe") {
                await new Promise((res) => {
                    dntShim.setTimeout(res, 1000);
                });
                return;
            }
            else if (failure === "name_taken") {
                attemptsInLastTenSeconds += 1;
                const removalTimer = dntShim.setTimeout(() => {
                    attemptsInLastTenSeconds -= 1;
                }, 10000);
                removalTimers.push(removalTimer);
                renameAttempts += 1;
            }
            else if (failure === "aborted") {
                return Promise.reject("Advertisement was aborted.");
            }
        });
    }
    for (const timer of removalTimers) {
        clearTimeout(timer);
    }
    return Promise.reject(new Error("Was not able to claim a name after 15 attempts, which indicates shenanigans."));
}
