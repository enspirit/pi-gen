import { MDNS_IPV4, MDNS_IPV6, MDNS_PORT } from "./constants.js";
import { createSocket, } from "node:dgram";
import { hostname, networkInterfaces, } from "node:os";
import { FastFIFO } from "../fast_fifo.js";
import { deferred } from "../../deps/deno.land/std@0.177.0/async/deferred.js";
export class DefaultDriver {
    constructor(family) {
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new FastFIFO(16)
        });
        Object.defineProperty(this, "family", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "address", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hostname", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: hostname()
        });
        this.family = family;
        const socket = createSocket(family === "IPv4" ? "udp4" : "udp6");
        this.socket = socket;
        this.address = family === "IPv4" ? "0.0.0.0" : "::";
        socket.bind(MDNS_PORT, undefined, () => {
            socket.addMembership(family === "IPv4" ? MDNS_IPV4 : MDNS_IPV6);
        });
        socket.on("message", (msg, rinfo) => {
            this.messages.push([
                msg,
                { hostname: rinfo.address, port: rinfo.port },
            ]);
        });
    }
    send(message) {
        return new Promise((res) => {
            this.socket.send(message, MDNS_PORT, this.family === "IPv4" ? MDNS_IPV4 : MDNS_IPV6, () => {
                res();
            });
        });
    }
    setTTL(ttl) {
        this.socket.setMulticastTTL(ttl);
        return Promise.resolve();
    }
    setLoopback(loopback) {
        this.socket.setMulticastLoopback(loopback);
        return Promise.resolve();
    }
    receive() {
        const h = deferred();
        (async () => {
            for await (const msg of this.messages) {
                h.resolve(msg);
                break;
            }
        })();
        return h;
    }
    isOwnAddress(address) {
        const interfaces = networkInterfaces();
        for (const key in interfaces) {
            const intf = networkInterfaces()[key];
            for (const addr in intf) {
                if (addr === address) {
                    return true;
                }
            }
        }
        return false;
    }
    close() {
        this.socket.close();
    }
}
